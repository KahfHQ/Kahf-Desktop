var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var sessionTranslation_exports = {};
__export(sessionTranslation_exports, {
  sessionRecordToProtobuf: () => sessionRecordToProtobuf,
  sessionStructureToBytes: () => sessionStructureToBytes
});
module.exports = __toCommonJS(sessionTranslation_exports);
var import_lodash = require("lodash");
var import_compiled = require("../protobuf/compiled");
var Bytes = __toESM(require("../Bytes"));
var import_Crypto = require("../Crypto");
const { RecordStructure, SessionStructure } = import_compiled.signal.proto.storage;
const { Chain } = SessionStructure;
function sessionStructureToBytes(recordStructure) {
  return import_compiled.signal.proto.storage.RecordStructure.encode(recordStructure).finish();
}
function sessionRecordToProtobuf(record, ourData) {
  const proto = new RecordStructure();
  proto.previousSessions = [];
  const sessionGroup = record.sessions || {};
  const sessions = Object.values(sessionGroup);
  const first = sessions.find((session) => {
    return session?.indexInfo?.closed === -1;
  });
  if (first) {
    proto.currentSession = toProtobufSession(first, ourData);
  }
  sessions.sort((left, right) => {
    return (right?.indexInfo?.closed || 0) - (left?.indexInfo?.closed || 0);
  });
  const onlyClosed = sessions.filter((session) => session?.indexInfo?.closed !== -1);
  if (onlyClosed.length < sessions.length - 1) {
    throw new Error("toProtobuf: More than one open session!");
  }
  proto.previousSessions = [];
  onlyClosed.forEach((session) => {
    proto.previousSessions.push(toProtobufSession(session, ourData));
  });
  if (!proto.currentSession && proto.previousSessions.length === 0) {
    throw new Error("toProtobuf: Record had no sessions!");
  }
  return proto;
}
function toProtobufSession(session, ourData) {
  const proto = new SessionStructure();
  proto.aliceBaseKey = binaryToUint8Array(session, "indexInfo.baseKey", 33);
  proto.localIdentityPublic = ourData.identityKeyPublic;
  proto.localRegistrationId = ourData.registrationId;
  proto.previousCounter = getInteger(session, "currentRatchet.previousCounter") + 1;
  proto.remoteIdentityPublic = binaryToUint8Array(session, "indexInfo.remoteIdentityKey", 33);
  proto.remoteRegistrationId = getInteger(session, "registrationId");
  proto.rootKey = binaryToUint8Array(session, "currentRatchet.rootKey", 32);
  proto.sessionVersion = 3;
  if (session.pendingPreKey) {
    proto.pendingPreKey = new import_compiled.signal.proto.storage.SessionStructure.PendingPreKey();
    proto.pendingPreKey.baseKey = binaryToUint8Array(session, "pendingPreKey.baseKey", 33);
    proto.pendingPreKey.signedPreKeyId = getInteger(session, "pendingPreKey.signedKeyId");
    if (session.pendingPreKey.preKeyId !== void 0) {
      proto.pendingPreKey.preKeyId = getInteger(session, "pendingPreKey.preKeyId");
    }
  }
  const senderBaseKey = session.currentRatchet?.ephemeralKeyPair?.pubKey;
  if (!senderBaseKey) {
    throw new Error("toProtobufSession: No sender base key!");
  }
  const senderChain = session[senderBaseKey];
  if (!senderChain) {
    throw new Error("toProtobufSession: No matching chain found with senderBaseKey!");
  }
  if (senderChain.chainType !== 1) {
    throw new Error(`toProtobufSession: Expected sender chain type for senderChain, got ${senderChain.chainType}`);
  }
  const protoSenderChain = toProtobufChain(senderChain);
  protoSenderChain.senderRatchetKey = binaryToUint8Array(session, "currentRatchet.ephemeralKeyPair.pubKey", 33);
  protoSenderChain.senderRatchetKeyPrivate = binaryToUint8Array(session, "currentRatchet.ephemeralKeyPair.privKey", 32);
  proto.senderChain = protoSenderChain;
  proto.receiverChains = [];
  const firstReceiverChainBaseKey = session.currentRatchet?.lastRemoteEphemeralKey;
  if (!firstReceiverChainBaseKey) {
    throw new Error("toProtobufSession: No receiver base key!");
  }
  const firstReceiverChain = session[firstReceiverChainBaseKey];
  if (firstReceiverChain) {
    const protoFirstReceiverChain = toProtobufChain(firstReceiverChain);
    if (firstReceiverChain.chainType !== 2) {
      throw new Error(`toProtobufSession: Expected receiver chain type for firstReceiverChain, got ${firstReceiverChain.chainType}`);
    }
    protoFirstReceiverChain.senderRatchetKey = binaryToUint8Array(session, "currentRatchet.lastRemoteEphemeralKey", 33);
    proto.receiverChains.push(protoFirstReceiverChain);
  }
  const oldChains = (session.oldRatchetList || []).slice(0).sort((left, right) => (right.added || 0) - (left.added || 0));
  oldChains.forEach((oldRatchet) => {
    const baseKey = oldRatchet.ephemeralKey;
    if (!baseKey) {
      throw new Error("toProtobufSession: No base key for old receiver chain!");
    }
    const chain = session[baseKey];
    if (!chain) {
      throw new Error("toProtobufSession: No chain for old receiver chain base key!");
    }
    if (chain.chainType !== 2) {
      throw new Error(`toProtobufSession: Expected receiver chain type, got ${chain.chainType}`);
    }
    const protoChain = toProtobufChain(chain);
    protoChain.senderRatchetKey = binaryToUint8Array(oldRatchet, "ephemeralKey", 33);
    proto.receiverChains.push(protoChain);
  });
  return proto;
}
function toProtobufChain(chain) {
  const proto = new Chain();
  const protoChainKey = new Chain.ChainKey();
  protoChainKey.index = getInteger(chain, "chainKey.counter") + 1;
  if (chain.chainKey?.key !== void 0) {
    protoChainKey.key = binaryToUint8Array(chain, "chainKey.key", 32);
  }
  proto.chainKey = protoChainKey;
  const messageKeys = Object.entries(chain.messageKeys || {});
  proto.messageKeys = messageKeys.map((entry) => {
    const protoMessageKey = new SessionStructure.Chain.MessageKey();
    protoMessageKey.index = getInteger(entry, "0") + 1;
    const key = binaryToUint8Array(entry, "1", 32);
    const { cipherKey, macKey, iv } = translateMessageKey(key);
    protoMessageKey.cipherKey = cipherKey;
    protoMessageKey.macKey = macKey;
    protoMessageKey.iv = iv;
    return protoMessageKey;
  });
  return proto;
}
const WHISPER_MESSAGE_KEYS = "WhisperMessageKeys";
function translateMessageKey(key) {
  const input = key;
  const salt = new Uint8Array(32);
  const info = Bytes.fromString(WHISPER_MESSAGE_KEYS);
  const [cipherKey, macKey, ivContainer] = (0, import_Crypto.deriveSecrets)(input, salt, info);
  return {
    cipherKey,
    macKey,
    iv: ivContainer.slice(0, 16)
  };
}
function binaryToUint8Array(object, path, length) {
  const target = (0, import_lodash.get)(object, path);
  if (target === null || target === void 0) {
    throw new Error(`binaryToUint8Array: Falsey path ${path}`);
  }
  if (!(0, import_lodash.isString)(target)) {
    throw new Error(`binaryToUint8Array: String not found at path ${path}`);
  }
  const buffer = Bytes.fromBinary(target);
  if (length && buffer.byteLength !== length) {
    throw new Error(`binaryToUint8Array: Got unexpected length ${buffer.byteLength} instead of ${length} at path ${path}`);
  }
  return buffer;
}
function getInteger(object, path) {
  const target = (0, import_lodash.get)(object, path);
  if (target === null || target === void 0) {
    throw new Error(`getInteger: Falsey path ${path}`);
  }
  if ((0, import_lodash.isString)(target)) {
    const result = parseInt(target, 10);
    if (!(0, import_lodash.isFinite)(result)) {
      throw new Error(`getInteger: Value could not be parsed as number at ${path}: {target}`);
    }
    if (!(0, import_lodash.isInteger)(result)) {
      throw new Error(`getInteger: Parsed value not an integer at ${path}: {target}`);
    }
    return result;
  }
  if (!(0, import_lodash.isInteger)(target)) {
    throw new Error(`getInteger: Value not an integer at ${path}: {target}`);
  }
  return target;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  sessionRecordToProtobuf,
  sessionStructureToBytes
});
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsic2Vzc2lvblRyYW5zbGF0aW9uLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyIvLyBDb3B5cmlnaHQgMjAyMSBTaWduYWwgTWVzc2VuZ2VyLCBMTENcbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBR1BMLTMuMC1vbmx5XG5cbmltcG9ydCB7IGdldCwgaXNGaW5pdGUsIGlzSW50ZWdlciwgaXNTdHJpbmcgfSBmcm9tICdsb2Rhc2gnO1xuXG5pbXBvcnQgeyBzaWduYWwgfSBmcm9tICcuLi9wcm90b2J1Zi9jb21waWxlZCc7XG5pbXBvcnQgKiBhcyBCeXRlcyBmcm9tICcuLi9CeXRlcyc7XG5pbXBvcnQgeyBkZXJpdmVTZWNyZXRzIH0gZnJvbSAnLi4vQ3J5cHRvJztcblxuY29uc3QgeyBSZWNvcmRTdHJ1Y3R1cmUsIFNlc3Npb25TdHJ1Y3R1cmUgfSA9IHNpZ25hbC5wcm90by5zdG9yYWdlO1xuY29uc3QgeyBDaGFpbiB9ID0gU2Vzc2lvblN0cnVjdHVyZTtcblxudHlwZSBLZXlQYWlyVHlwZSA9IHtcbiAgcHJpdktleT86IHN0cmluZztcbiAgcHViS2V5Pzogc3RyaW5nO1xufTtcblxudHlwZSBPbGRSYXRjaGV0VHlwZSA9IHtcbiAgYWRkZWQ/OiBudW1iZXI7XG4gIGVwaGVtZXJhbEtleT86IHN0cmluZztcbn07XG5cbnR5cGUgU2Vzc2lvblR5cGUgPSB7XG4gIHJlZ2lzdHJhdGlvbklkPzogbnVtYmVyO1xuICBjdXJyZW50UmF0Y2hldD86IHtcbiAgICByb290S2V5Pzogc3RyaW5nO1xuICAgIGxhc3RSZW1vdGVFcGhlbWVyYWxLZXk/OiBzdHJpbmc7XG4gICAgcHJldmlvdXNDb3VudGVyPzogbnVtYmVyO1xuICAgIGVwaGVtZXJhbEtleVBhaXI/OiBLZXlQYWlyVHlwZTtcbiAgfTtcbiAgaW5kZXhJbmZvPzoge1xuICAgIHJlbW90ZUlkZW50aXR5S2V5Pzogc3RyaW5nO1xuICAgIGNsb3NlZD86IG51bWJlcjtcbiAgICBiYXNlS2V5Pzogc3RyaW5nO1xuICAgIGJhc2VLZXlUeXBlPzogbnVtYmVyO1xuICB9O1xuICBwZW5kaW5nUHJlS2V5Pzoge1xuICAgIGJhc2VLZXk/OiBzdHJpbmc7XG4gICAgc2lnbmVkUHJlS2V5SWQ/OiBudW1iZXI7XG4gICAgLy8gVGhlIGZpcnN0IHR3byBhcmUgcmVxdWlyZWQ7IHRoaXMgb25lIGlzIG9wdGlvbmFsXG4gICAgcHJlS2V5SWQ/OiBudW1iZXI7XG4gIH07XG4gIG9sZFJhdGNoZXRMaXN0PzogQXJyYXk8T2xkUmF0Y2hldFR5cGU+O1xuXG4gIC8vIE5vdGU6IENoYWluVHlwZXMgYXJlIHN0b3JlZCBoZXJlLCBrZXllZCBieSB0aGVpciBiYXNlS2V5LiBUeXBlc2NyaXB0XG4gIC8vLyAgZG9lc24ndCBhbGxvdyB0aGF0IGtpbmQgb2YgY29tYmluYXRpb24gZGVmaW5pdGlvbiAoa25vd24ga2V5cyBhbmRcbiAgLy8gICBpbmRleGVyKSwgc28gd2UgZm9yY2Ugc2Vzc2lvbiB0byBgYW55YCBiZWxvdyB3aGVuZXZlciB3ZSBhY2Nlc3MgaXQgbGlrZVxuICAvLyAgIGBzZXNzaW9uW2Jhc2VLZXldYC5cbn07XG5cbnR5cGUgTWVzc2FnZUtleUdyb3VwID0ge1xuICBba2V5OiBzdHJpbmddOiBzdHJpbmc7XG59O1xuXG50eXBlIENoYWluVHlwZSA9IHtcbiAgbWVzc2FnZUtleXM/OiBNZXNzYWdlS2V5R3JvdXA7XG4gIGNoYWluS2V5Pzoge1xuICAgIGNvdW50ZXI/OiBudW1iZXI7XG4gICAga2V5Pzogc3RyaW5nO1xuICB9O1xuICBjaGFpblR5cGU6IG51bWJlcjtcbn07XG5cbnR5cGUgU2Vzc2lvbkxpc3RUeXBlID0ge1xuICBba2V5OiBzdHJpbmddOiBTZXNzaW9uVHlwZTtcbn07XG5cbnR5cGUgU2Vzc2lvblJlY29yZFR5cGUgPSB7XG4gIHNlc3Npb25zPzogU2Vzc2lvbkxpc3RUeXBlO1xuICB2ZXJzaW9uPzogJ3YxJztcbn07XG5cbmV4cG9ydCB0eXBlIExvY2FsVXNlckRhdGFUeXBlID0ge1xuICBpZGVudGl0eUtleVB1YmxpYzogVWludDhBcnJheTtcbiAgcmVnaXN0cmF0aW9uSWQ6IG51bWJlcjtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXNzaW9uU3RydWN0dXJlVG9CeXRlcyhcbiAgcmVjb3JkU3RydWN0dXJlOiBzaWduYWwucHJvdG8uc3RvcmFnZS5SZWNvcmRTdHJ1Y3R1cmVcbik6IFVpbnQ4QXJyYXkge1xuICByZXR1cm4gc2lnbmFsLnByb3RvLnN0b3JhZ2UuUmVjb3JkU3RydWN0dXJlLmVuY29kZShyZWNvcmRTdHJ1Y3R1cmUpLmZpbmlzaCgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2Vzc2lvblJlY29yZFRvUHJvdG9idWYoXG4gIHJlY29yZDogU2Vzc2lvblJlY29yZFR5cGUsXG4gIG91ckRhdGE6IExvY2FsVXNlckRhdGFUeXBlXG4pOiBzaWduYWwucHJvdG8uc3RvcmFnZS5SZWNvcmRTdHJ1Y3R1cmUge1xuICBjb25zdCBwcm90byA9IG5ldyBSZWNvcmRTdHJ1Y3R1cmUoKTtcblxuICBwcm90by5wcmV2aW91c1Nlc3Npb25zID0gW107XG5cbiAgY29uc3Qgc2Vzc2lvbkdyb3VwID0gcmVjb3JkLnNlc3Npb25zIHx8IHt9O1xuICBjb25zdCBzZXNzaW9ucyA9IE9iamVjdC52YWx1ZXMoc2Vzc2lvbkdyb3VwKTtcblxuICBjb25zdCBmaXJzdCA9IHNlc3Npb25zLmZpbmQoc2Vzc2lvbiA9PiB7XG4gICAgcmV0dXJuIHNlc3Npb24/LmluZGV4SW5mbz8uY2xvc2VkID09PSAtMTtcbiAgfSk7XG5cbiAgaWYgKGZpcnN0KSB7XG4gICAgcHJvdG8uY3VycmVudFNlc3Npb24gPSB0b1Byb3RvYnVmU2Vzc2lvbihmaXJzdCwgb3VyRGF0YSk7XG4gIH1cblxuICBzZXNzaW9ucy5zb3J0KChsZWZ0LCByaWdodCkgPT4ge1xuICAgIC8vIERlc2NlbmRpbmcgLSB3ZSB3YW50IHJlY2VudGx5LWNsb3NlZCBzZXNzaW9ucyB0byBiZSBmaXJzdFxuICAgIHJldHVybiAocmlnaHQ/LmluZGV4SW5mbz8uY2xvc2VkIHx8IDApIC0gKGxlZnQ/LmluZGV4SW5mbz8uY2xvc2VkIHx8IDApO1xuICB9KTtcbiAgY29uc3Qgb25seUNsb3NlZCA9IHNlc3Npb25zLmZpbHRlcihcbiAgICBzZXNzaW9uID0+IHNlc3Npb24/LmluZGV4SW5mbz8uY2xvc2VkICE9PSAtMVxuICApO1xuXG4gIGlmIChvbmx5Q2xvc2VkLmxlbmd0aCA8IHNlc3Npb25zLmxlbmd0aCAtIDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3RvUHJvdG9idWY6IE1vcmUgdGhhbiBvbmUgb3BlbiBzZXNzaW9uIScpO1xuICB9XG5cbiAgcHJvdG8ucHJldmlvdXNTZXNzaW9ucyA9IFtdO1xuICBvbmx5Q2xvc2VkLmZvckVhY2goc2Vzc2lvbiA9PiB7XG4gICAgcHJvdG8ucHJldmlvdXNTZXNzaW9ucy5wdXNoKHRvUHJvdG9idWZTZXNzaW9uKHNlc3Npb24sIG91ckRhdGEpKTtcbiAgfSk7XG5cbiAgaWYgKCFwcm90by5jdXJyZW50U2Vzc2lvbiAmJiBwcm90by5wcmV2aW91c1Nlc3Npb25zLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcigndG9Qcm90b2J1ZjogUmVjb3JkIGhhZCBubyBzZXNzaW9ucyEnKTtcbiAgfVxuXG4gIHJldHVybiBwcm90bztcbn1cblxuZnVuY3Rpb24gdG9Qcm90b2J1ZlNlc3Npb24oXG4gIHNlc3Npb246IFNlc3Npb25UeXBlLFxuICBvdXJEYXRhOiBMb2NhbFVzZXJEYXRhVHlwZVxuKTogc2lnbmFsLnByb3RvLnN0b3JhZ2UuU2Vzc2lvblN0cnVjdHVyZSB7XG4gIGNvbnN0IHByb3RvID0gbmV3IFNlc3Npb25TdHJ1Y3R1cmUoKTtcblxuICAvLyBDb3JlIEZpZWxkc1xuXG4gIHByb3RvLmFsaWNlQmFzZUtleSA9IGJpbmFyeVRvVWludDhBcnJheShzZXNzaW9uLCAnaW5kZXhJbmZvLmJhc2VLZXknLCAzMyk7XG4gIHByb3RvLmxvY2FsSWRlbnRpdHlQdWJsaWMgPSBvdXJEYXRhLmlkZW50aXR5S2V5UHVibGljO1xuICBwcm90by5sb2NhbFJlZ2lzdHJhdGlvbklkID0gb3VyRGF0YS5yZWdpc3RyYXRpb25JZDtcblxuICBwcm90by5wcmV2aW91c0NvdW50ZXIgPVxuICAgIGdldEludGVnZXIoc2Vzc2lvbiwgJ2N1cnJlbnRSYXRjaGV0LnByZXZpb3VzQ291bnRlcicpICsgMTtcbiAgcHJvdG8ucmVtb3RlSWRlbnRpdHlQdWJsaWMgPSBiaW5hcnlUb1VpbnQ4QXJyYXkoXG4gICAgc2Vzc2lvbixcbiAgICAnaW5kZXhJbmZvLnJlbW90ZUlkZW50aXR5S2V5JyxcbiAgICAzM1xuICApO1xuICBwcm90by5yZW1vdGVSZWdpc3RyYXRpb25JZCA9IGdldEludGVnZXIoc2Vzc2lvbiwgJ3JlZ2lzdHJhdGlvbklkJyk7XG4gIHByb3RvLnJvb3RLZXkgPSBiaW5hcnlUb1VpbnQ4QXJyYXkoc2Vzc2lvbiwgJ2N1cnJlbnRSYXRjaGV0LnJvb3RLZXknLCAzMik7XG4gIHByb3RvLnNlc3Npb25WZXJzaW9uID0gMztcblxuICAvLyBOb3RlOiBjdXJyZW50bHkgdW51c2VkXG4gIC8vIHByb3RvLm5lZWRzUmVmcmVzaCA9IG51bGw7XG5cbiAgLy8gUGVuZGluZyBQcmVLZXlcblxuICBpZiAoc2Vzc2lvbi5wZW5kaW5nUHJlS2V5KSB7XG4gICAgcHJvdG8ucGVuZGluZ1ByZUtleSA9XG4gICAgICBuZXcgc2lnbmFsLnByb3RvLnN0b3JhZ2UuU2Vzc2lvblN0cnVjdHVyZS5QZW5kaW5nUHJlS2V5KCk7XG4gICAgcHJvdG8ucGVuZGluZ1ByZUtleS5iYXNlS2V5ID0gYmluYXJ5VG9VaW50OEFycmF5KFxuICAgICAgc2Vzc2lvbixcbiAgICAgICdwZW5kaW5nUHJlS2V5LmJhc2VLZXknLFxuICAgICAgMzNcbiAgICApO1xuICAgIHByb3RvLnBlbmRpbmdQcmVLZXkuc2lnbmVkUHJlS2V5SWQgPSBnZXRJbnRlZ2VyKFxuICAgICAgc2Vzc2lvbixcbiAgICAgICdwZW5kaW5nUHJlS2V5LnNpZ25lZEtleUlkJ1xuICAgICk7XG5cbiAgICBpZiAoc2Vzc2lvbi5wZW5kaW5nUHJlS2V5LnByZUtleUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHByb3RvLnBlbmRpbmdQcmVLZXkucHJlS2V5SWQgPSBnZXRJbnRlZ2VyKFxuICAgICAgICBzZXNzaW9uLFxuICAgICAgICAncGVuZGluZ1ByZUtleS5wcmVLZXlJZCdcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLy8gU2VuZGVyIENoYWluXG5cbiAgY29uc3Qgc2VuZGVyQmFzZUtleSA9IHNlc3Npb24uY3VycmVudFJhdGNoZXQ/LmVwaGVtZXJhbEtleVBhaXI/LnB1YktleTtcbiAgaWYgKCFzZW5kZXJCYXNlS2V5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd0b1Byb3RvYnVmU2Vzc2lvbjogTm8gc2VuZGVyIGJhc2Uga2V5IScpO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gIGNvbnN0IHNlbmRlckNoYWluID0gKHNlc3Npb24gYXMgYW55KVtzZW5kZXJCYXNlS2V5XSBhcyBDaGFpblR5cGUgfCB1bmRlZmluZWQ7XG4gIGlmICghc2VuZGVyQ2hhaW4pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAndG9Qcm90b2J1ZlNlc3Npb246IE5vIG1hdGNoaW5nIGNoYWluIGZvdW5kIHdpdGggc2VuZGVyQmFzZUtleSEnXG4gICAgKTtcbiAgfVxuXG4gIGlmIChzZW5kZXJDaGFpbi5jaGFpblR5cGUgIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgdG9Qcm90b2J1ZlNlc3Npb246IEV4cGVjdGVkIHNlbmRlciBjaGFpbiB0eXBlIGZvciBzZW5kZXJDaGFpbiwgZ290ICR7c2VuZGVyQ2hhaW4uY2hhaW5UeXBlfWBcbiAgICApO1xuICB9XG5cbiAgY29uc3QgcHJvdG9TZW5kZXJDaGFpbiA9IHRvUHJvdG9idWZDaGFpbihzZW5kZXJDaGFpbik7XG5cbiAgcHJvdG9TZW5kZXJDaGFpbi5zZW5kZXJSYXRjaGV0S2V5ID0gYmluYXJ5VG9VaW50OEFycmF5KFxuICAgIHNlc3Npb24sXG4gICAgJ2N1cnJlbnRSYXRjaGV0LmVwaGVtZXJhbEtleVBhaXIucHViS2V5JyxcbiAgICAzM1xuICApO1xuICBwcm90b1NlbmRlckNoYWluLnNlbmRlclJhdGNoZXRLZXlQcml2YXRlID0gYmluYXJ5VG9VaW50OEFycmF5KFxuICAgIHNlc3Npb24sXG4gICAgJ2N1cnJlbnRSYXRjaGV0LmVwaGVtZXJhbEtleVBhaXIucHJpdktleScsXG4gICAgMzJcbiAgKTtcblxuICBwcm90by5zZW5kZXJDaGFpbiA9IHByb3RvU2VuZGVyQ2hhaW47XG5cbiAgLy8gRmlyc3QgUmVjZWl2ZXIgQ2hhaW5cblxuICBwcm90by5yZWNlaXZlckNoYWlucyA9IFtdO1xuXG4gIGNvbnN0IGZpcnN0UmVjZWl2ZXJDaGFpbkJhc2VLZXkgPVxuICAgIHNlc3Npb24uY3VycmVudFJhdGNoZXQ/Lmxhc3RSZW1vdGVFcGhlbWVyYWxLZXk7XG4gIGlmICghZmlyc3RSZWNlaXZlckNoYWluQmFzZUtleSkge1xuICAgIHRocm93IG5ldyBFcnJvcigndG9Qcm90b2J1ZlNlc3Npb246IE5vIHJlY2VpdmVyIGJhc2Uga2V5IScpO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgY29uc3QgZmlyc3RSZWNlaXZlckNoYWluID0gKHNlc3Npb24gYXMgYW55KVtmaXJzdFJlY2VpdmVyQ2hhaW5CYXNlS2V5XSBhc1xuICAgIHwgQ2hhaW5UeXBlXG4gICAgfCB1bmRlZmluZWQ7XG5cbiAgLy8gSWYgdGhlIHNlc3Npb24gd2FzIGp1c3QgaW5pdGlhbGl6ZWQsIHRoZW4gdGhlcmUgd2lsbCBiZSBubyByZWNlaXZlciBjaGFpblxuICBpZiAoZmlyc3RSZWNlaXZlckNoYWluKSB7XG4gICAgY29uc3QgcHJvdG9GaXJzdFJlY2VpdmVyQ2hhaW4gPSB0b1Byb3RvYnVmQ2hhaW4oZmlyc3RSZWNlaXZlckNoYWluKTtcblxuICAgIGlmIChmaXJzdFJlY2VpdmVyQ2hhaW4uY2hhaW5UeXBlICE9PSAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGB0b1Byb3RvYnVmU2Vzc2lvbjogRXhwZWN0ZWQgcmVjZWl2ZXIgY2hhaW4gdHlwZSBmb3IgZmlyc3RSZWNlaXZlckNoYWluLCBnb3QgJHtmaXJzdFJlY2VpdmVyQ2hhaW4uY2hhaW5UeXBlfWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcHJvdG9GaXJzdFJlY2VpdmVyQ2hhaW4uc2VuZGVyUmF0Y2hldEtleSA9IGJpbmFyeVRvVWludDhBcnJheShcbiAgICAgIHNlc3Npb24sXG4gICAgICAnY3VycmVudFJhdGNoZXQubGFzdFJlbW90ZUVwaGVtZXJhbEtleScsXG4gICAgICAzM1xuICAgICk7XG5cbiAgICBwcm90by5yZWNlaXZlckNoYWlucy5wdXNoKHByb3RvRmlyc3RSZWNlaXZlckNoYWluKTtcbiAgfVxuXG4gIC8vIE9sZCBSZWNlaXZlciBDaGFpbnNcblxuICBjb25zdCBvbGRDaGFpbnMgPSAoc2Vzc2lvbi5vbGRSYXRjaGV0TGlzdCB8fCBbXSlcbiAgICAuc2xpY2UoMClcbiAgICAuc29ydCgobGVmdCwgcmlnaHQpID0+IChyaWdodC5hZGRlZCB8fCAwKSAtIChsZWZ0LmFkZGVkIHx8IDApKTtcbiAgb2xkQ2hhaW5zLmZvckVhY2gob2xkUmF0Y2hldCA9PiB7XG4gICAgY29uc3QgYmFzZUtleSA9IG9sZFJhdGNoZXQuZXBoZW1lcmFsS2V5O1xuICAgIGlmICghYmFzZUtleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0b1Byb3RvYnVmU2Vzc2lvbjogTm8gYmFzZSBrZXkgZm9yIG9sZCByZWNlaXZlciBjaGFpbiEnKTtcbiAgICB9XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGNvbnN0IGNoYWluID0gKHNlc3Npb24gYXMgYW55KVtiYXNlS2V5XSBhcyBDaGFpblR5cGUgfCB1bmRlZmluZWQ7XG4gICAgaWYgKCFjaGFpbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAndG9Qcm90b2J1ZlNlc3Npb246IE5vIGNoYWluIGZvciBvbGQgcmVjZWl2ZXIgY2hhaW4gYmFzZSBrZXkhJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoY2hhaW4uY2hhaW5UeXBlICE9PSAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGB0b1Byb3RvYnVmU2Vzc2lvbjogRXhwZWN0ZWQgcmVjZWl2ZXIgY2hhaW4gdHlwZSwgZ290ICR7Y2hhaW4uY2hhaW5UeXBlfWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgcHJvdG9DaGFpbiA9IHRvUHJvdG9idWZDaGFpbihjaGFpbik7XG5cbiAgICBwcm90b0NoYWluLnNlbmRlclJhdGNoZXRLZXkgPSBiaW5hcnlUb1VpbnQ4QXJyYXkoXG4gICAgICBvbGRSYXRjaGV0LFxuICAgICAgJ2VwaGVtZXJhbEtleScsXG4gICAgICAzM1xuICAgICk7XG5cbiAgICBwcm90by5yZWNlaXZlckNoYWlucy5wdXNoKHByb3RvQ2hhaW4pO1xuICB9KTtcblxuICByZXR1cm4gcHJvdG87XG59XG5cbmZ1bmN0aW9uIHRvUHJvdG9idWZDaGFpbihcbiAgY2hhaW46IENoYWluVHlwZVxuKTogc2lnbmFsLnByb3RvLnN0b3JhZ2UuU2Vzc2lvblN0cnVjdHVyZS5DaGFpbiB7XG4gIGNvbnN0IHByb3RvID0gbmV3IENoYWluKCk7XG5cbiAgY29uc3QgcHJvdG9DaGFpbktleSA9IG5ldyBDaGFpbi5DaGFpbktleSgpO1xuICBwcm90b0NoYWluS2V5LmluZGV4ID0gZ2V0SW50ZWdlcihjaGFpbiwgJ2NoYWluS2V5LmNvdW50ZXInKSArIDE7XG4gIGlmIChjaGFpbi5jaGFpbktleT8ua2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICBwcm90b0NoYWluS2V5LmtleSA9IGJpbmFyeVRvVWludDhBcnJheShjaGFpbiwgJ2NoYWluS2V5LmtleScsIDMyKTtcbiAgfVxuICBwcm90by5jaGFpbktleSA9IHByb3RvQ2hhaW5LZXk7XG5cbiAgY29uc3QgbWVzc2FnZUtleXMgPSBPYmplY3QuZW50cmllcyhjaGFpbi5tZXNzYWdlS2V5cyB8fCB7fSk7XG4gIHByb3RvLm1lc3NhZ2VLZXlzID0gbWVzc2FnZUtleXMubWFwKGVudHJ5ID0+IHtcbiAgICBjb25zdCBwcm90b01lc3NhZ2VLZXkgPSBuZXcgU2Vzc2lvblN0cnVjdHVyZS5DaGFpbi5NZXNzYWdlS2V5KCk7XG4gICAgcHJvdG9NZXNzYWdlS2V5LmluZGV4ID0gZ2V0SW50ZWdlcihlbnRyeSwgJzAnKSArIDE7XG4gICAgY29uc3Qga2V5ID0gYmluYXJ5VG9VaW50OEFycmF5KGVudHJ5LCAnMScsIDMyKTtcblxuICAgIGNvbnN0IHsgY2lwaGVyS2V5LCBtYWNLZXksIGl2IH0gPSB0cmFuc2xhdGVNZXNzYWdlS2V5KGtleSk7XG5cbiAgICBwcm90b01lc3NhZ2VLZXkuY2lwaGVyS2V5ID0gY2lwaGVyS2V5O1xuICAgIHByb3RvTWVzc2FnZUtleS5tYWNLZXkgPSBtYWNLZXk7XG4gICAgcHJvdG9NZXNzYWdlS2V5Lml2ID0gaXY7XG5cbiAgICByZXR1cm4gcHJvdG9NZXNzYWdlS2V5O1xuICB9KTtcblxuICByZXR1cm4gcHJvdG87XG59XG5cbi8vIFV0aWxpdHkgZnVuY3Rpb25zXG5cbmNvbnN0IFdISVNQRVJfTUVTU0FHRV9LRVlTID0gJ1doaXNwZXJNZXNzYWdlS2V5cyc7XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZU1lc3NhZ2VLZXkoa2V5OiBVaW50OEFycmF5KSB7XG4gIGNvbnN0IGlucHV0ID0ga2V5O1xuICBjb25zdCBzYWx0ID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICBjb25zdCBpbmZvID0gQnl0ZXMuZnJvbVN0cmluZyhXSElTUEVSX01FU1NBR0VfS0VZUyk7XG5cbiAgY29uc3QgW2NpcGhlcktleSwgbWFjS2V5LCBpdkNvbnRhaW5lcl0gPSBkZXJpdmVTZWNyZXRzKGlucHV0LCBzYWx0LCBpbmZvKTtcblxuICByZXR1cm4ge1xuICAgIGNpcGhlcktleSxcbiAgICBtYWNLZXksXG4gICAgaXY6IGl2Q29udGFpbmVyLnNsaWNlKDAsIDE2KSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gYmluYXJ5VG9VaW50OEFycmF5KFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICBvYmplY3Q6IGFueSxcbiAgcGF0aDogc3RyaW5nLFxuICBsZW5ndGg6IG51bWJlclxuKTogVWludDhBcnJheSB7XG4gIGNvbnN0IHRhcmdldCA9IGdldChvYmplY3QsIHBhdGgpO1xuICBpZiAodGFyZ2V0ID09PSBudWxsIHx8IHRhcmdldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBiaW5hcnlUb1VpbnQ4QXJyYXk6IEZhbHNleSBwYXRoICR7cGF0aH1gKTtcbiAgfVxuXG4gIGlmICghaXNTdHJpbmcodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgYmluYXJ5VG9VaW50OEFycmF5OiBTdHJpbmcgbm90IGZvdW5kIGF0IHBhdGggJHtwYXRofWApO1xuICB9XG5cbiAgY29uc3QgYnVmZmVyID0gQnl0ZXMuZnJvbUJpbmFyeSh0YXJnZXQpO1xuICBpZiAobGVuZ3RoICYmIGJ1ZmZlci5ieXRlTGVuZ3RoICE9PSBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgYmluYXJ5VG9VaW50OEFycmF5OiBHb3QgdW5leHBlY3RlZCBsZW5ndGggJHtidWZmZXIuYnl0ZUxlbmd0aH0gaW5zdGVhZCBvZiAke2xlbmd0aH0gYXQgcGF0aCAke3BhdGh9YFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gYnVmZmVyO1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gZ2V0SW50ZWdlcihvYmplY3Q6IGFueSwgcGF0aDogc3RyaW5nKTogbnVtYmVyIHtcbiAgY29uc3QgdGFyZ2V0ID0gZ2V0KG9iamVjdCwgcGF0aCk7XG4gIGlmICh0YXJnZXQgPT09IG51bGwgfHwgdGFyZ2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGdldEludGVnZXI6IEZhbHNleSBwYXRoICR7cGF0aH1gKTtcbiAgfVxuXG4gIGlmIChpc1N0cmluZyh0YXJnZXQpKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gcGFyc2VJbnQodGFyZ2V0LCAxMCk7XG4gICAgaWYgKCFpc0Zpbml0ZShyZXN1bHQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBnZXRJbnRlZ2VyOiBWYWx1ZSBjb3VsZCBub3QgYmUgcGFyc2VkIGFzIG51bWJlciBhdCAke3BhdGh9OiB7dGFyZ2V0fWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFpc0ludGVnZXIocmVzdWx0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgZ2V0SW50ZWdlcjogUGFyc2VkIHZhbHVlIG5vdCBhbiBpbnRlZ2VyIGF0ICR7cGF0aH06IHt0YXJnZXR9YFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKCFpc0ludGVnZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgZ2V0SW50ZWdlcjogVmFsdWUgbm90IGFuIGludGVnZXIgYXQgJHtwYXRofToge3RhcmdldH1gKTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFHQSxvQkFBbUQ7QUFFbkQsc0JBQXVCO0FBQ3ZCLFlBQXVCO0FBQ3ZCLG9CQUE4QjtBQUU5QixNQUFNLEVBQUUsaUJBQWlCLHFCQUFxQix1QkFBTyxNQUFNO0FBQzNELE1BQU0sRUFBRSxVQUFVO0FBbUVYLGlDQUNMLGlCQUNZO0FBQ1osU0FBTyx1QkFBTyxNQUFNLFFBQVEsZ0JBQWdCLE9BQU8sZUFBZSxFQUFFLE9BQU87QUFDN0U7QUFKZ0IsQUFNVCxpQ0FDTCxRQUNBLFNBQ3NDO0FBQ3RDLFFBQU0sUUFBUSxJQUFJLGdCQUFnQjtBQUVsQyxRQUFNLG1CQUFtQixDQUFDO0FBRTFCLFFBQU0sZUFBZSxPQUFPLFlBQVksQ0FBQztBQUN6QyxRQUFNLFdBQVcsT0FBTyxPQUFPLFlBQVk7QUFFM0MsUUFBTSxRQUFRLFNBQVMsS0FBSyxhQUFXO0FBQ3JDLFdBQU8sU0FBUyxXQUFXLFdBQVc7QUFBQSxFQUN4QyxDQUFDO0FBRUQsTUFBSSxPQUFPO0FBQ1QsVUFBTSxpQkFBaUIsa0JBQWtCLE9BQU8sT0FBTztBQUFBLEVBQ3pEO0FBRUEsV0FBUyxLQUFLLENBQUMsTUFBTSxVQUFVO0FBRTdCLFdBQVEsUUFBTyxXQUFXLFVBQVUsS0FBTSxPQUFNLFdBQVcsVUFBVTtBQUFBLEVBQ3ZFLENBQUM7QUFDRCxRQUFNLGFBQWEsU0FBUyxPQUMxQixhQUFXLFNBQVMsV0FBVyxXQUFXLEVBQzVDO0FBRUEsTUFBSSxXQUFXLFNBQVMsU0FBUyxTQUFTLEdBQUc7QUFDM0MsVUFBTSxJQUFJLE1BQU0seUNBQXlDO0FBQUEsRUFDM0Q7QUFFQSxRQUFNLG1CQUFtQixDQUFDO0FBQzFCLGFBQVcsUUFBUSxhQUFXO0FBQzVCLFVBQU0saUJBQWlCLEtBQUssa0JBQWtCLFNBQVMsT0FBTyxDQUFDO0FBQUEsRUFDakUsQ0FBQztBQUVELE1BQUksQ0FBQyxNQUFNLGtCQUFrQixNQUFNLGlCQUFpQixXQUFXLEdBQUc7QUFDaEUsVUFBTSxJQUFJLE1BQU0scUNBQXFDO0FBQUEsRUFDdkQ7QUFFQSxTQUFPO0FBQ1Q7QUF6Q2dCLEFBMkNoQiwyQkFDRSxTQUNBLFNBQ3VDO0FBQ3ZDLFFBQU0sUUFBUSxJQUFJLGlCQUFpQjtBQUluQyxRQUFNLGVBQWUsbUJBQW1CLFNBQVMscUJBQXFCLEVBQUU7QUFDeEUsUUFBTSxzQkFBc0IsUUFBUTtBQUNwQyxRQUFNLHNCQUFzQixRQUFRO0FBRXBDLFFBQU0sa0JBQ0osV0FBVyxTQUFTLGdDQUFnQyxJQUFJO0FBQzFELFFBQU0sdUJBQXVCLG1CQUMzQixTQUNBLCtCQUNBLEVBQ0Y7QUFDQSxRQUFNLHVCQUF1QixXQUFXLFNBQVMsZ0JBQWdCO0FBQ2pFLFFBQU0sVUFBVSxtQkFBbUIsU0FBUywwQkFBMEIsRUFBRTtBQUN4RSxRQUFNLGlCQUFpQjtBQU92QixNQUFJLFFBQVEsZUFBZTtBQUN6QixVQUFNLGdCQUNKLElBQUksdUJBQU8sTUFBTSxRQUFRLGlCQUFpQixjQUFjO0FBQzFELFVBQU0sY0FBYyxVQUFVLG1CQUM1QixTQUNBLHlCQUNBLEVBQ0Y7QUFDQSxVQUFNLGNBQWMsaUJBQWlCLFdBQ25DLFNBQ0EsMkJBQ0Y7QUFFQSxRQUFJLFFBQVEsY0FBYyxhQUFhLFFBQVc7QUFDaEQsWUFBTSxjQUFjLFdBQVcsV0FDN0IsU0FDQSx3QkFDRjtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBSUEsUUFBTSxnQkFBZ0IsUUFBUSxnQkFBZ0Isa0JBQWtCO0FBQ2hFLE1BQUksQ0FBQyxlQUFlO0FBQ2xCLFVBQU0sSUFBSSxNQUFNLHdDQUF3QztBQUFBLEVBQzFEO0FBRUEsUUFBTSxjQUFlLFFBQWdCO0FBQ3JDLE1BQUksQ0FBQyxhQUFhO0FBQ2hCLFVBQU0sSUFBSSxNQUNSLGdFQUNGO0FBQUEsRUFDRjtBQUVBLE1BQUksWUFBWSxjQUFjLEdBQUc7QUFDL0IsVUFBTSxJQUFJLE1BQ1Isc0VBQXNFLFlBQVksV0FDcEY7QUFBQSxFQUNGO0FBRUEsUUFBTSxtQkFBbUIsZ0JBQWdCLFdBQVc7QUFFcEQsbUJBQWlCLG1CQUFtQixtQkFDbEMsU0FDQSwwQ0FDQSxFQUNGO0FBQ0EsbUJBQWlCLDBCQUEwQixtQkFDekMsU0FDQSwyQ0FDQSxFQUNGO0FBRUEsUUFBTSxjQUFjO0FBSXBCLFFBQU0saUJBQWlCLENBQUM7QUFFeEIsUUFBTSw0QkFDSixRQUFRLGdCQUFnQjtBQUMxQixNQUFJLENBQUMsMkJBQTJCO0FBQzlCLFVBQU0sSUFBSSxNQUFNLDBDQUEwQztBQUFBLEVBQzVEO0FBR0EsUUFBTSxxQkFBc0IsUUFBZ0I7QUFLNUMsTUFBSSxvQkFBb0I7QUFDdEIsVUFBTSwwQkFBMEIsZ0JBQWdCLGtCQUFrQjtBQUVsRSxRQUFJLG1CQUFtQixjQUFjLEdBQUc7QUFDdEMsWUFBTSxJQUFJLE1BQ1IsK0VBQStFLG1CQUFtQixXQUNwRztBQUFBLElBQ0Y7QUFFQSw0QkFBd0IsbUJBQW1CLG1CQUN6QyxTQUNBLHlDQUNBLEVBQ0Y7QUFFQSxVQUFNLGVBQWUsS0FBSyx1QkFBdUI7QUFBQSxFQUNuRDtBQUlBLFFBQU0sWUFBYSxTQUFRLGtCQUFrQixDQUFDLEdBQzNDLE1BQU0sQ0FBQyxFQUNQLEtBQUssQ0FBQyxNQUFNLFVBQVcsT0FBTSxTQUFTLEtBQU0sTUFBSyxTQUFTLEVBQUU7QUFDL0QsWUFBVSxRQUFRLGdCQUFjO0FBQzlCLFVBQU0sVUFBVSxXQUFXO0FBQzNCLFFBQUksQ0FBQyxTQUFTO0FBQ1osWUFBTSxJQUFJLE1BQU0sd0RBQXdEO0FBQUEsSUFDMUU7QUFHQSxVQUFNLFFBQVMsUUFBZ0I7QUFDL0IsUUFBSSxDQUFDLE9BQU87QUFDVixZQUFNLElBQUksTUFDUiw4REFDRjtBQUFBLElBQ0Y7QUFFQSxRQUFJLE1BQU0sY0FBYyxHQUFHO0FBQ3pCLFlBQU0sSUFBSSxNQUNSLHdEQUF3RCxNQUFNLFdBQ2hFO0FBQUEsSUFDRjtBQUVBLFVBQU0sYUFBYSxnQkFBZ0IsS0FBSztBQUV4QyxlQUFXLG1CQUFtQixtQkFDNUIsWUFDQSxnQkFDQSxFQUNGO0FBRUEsVUFBTSxlQUFlLEtBQUssVUFBVTtBQUFBLEVBQ3RDLENBQUM7QUFFRCxTQUFPO0FBQ1Q7QUEzSlMsQUE2SlQseUJBQ0UsT0FDNkM7QUFDN0MsUUFBTSxRQUFRLElBQUksTUFBTTtBQUV4QixRQUFNLGdCQUFnQixJQUFJLE1BQU0sU0FBUztBQUN6QyxnQkFBYyxRQUFRLFdBQVcsT0FBTyxrQkFBa0IsSUFBSTtBQUM5RCxNQUFJLE1BQU0sVUFBVSxRQUFRLFFBQVc7QUFDckMsa0JBQWMsTUFBTSxtQkFBbUIsT0FBTyxnQkFBZ0IsRUFBRTtBQUFBLEVBQ2xFO0FBQ0EsUUFBTSxXQUFXO0FBRWpCLFFBQU0sY0FBYyxPQUFPLFFBQVEsTUFBTSxlQUFlLENBQUMsQ0FBQztBQUMxRCxRQUFNLGNBQWMsWUFBWSxJQUFJLFdBQVM7QUFDM0MsVUFBTSxrQkFBa0IsSUFBSSxpQkFBaUIsTUFBTSxXQUFXO0FBQzlELG9CQUFnQixRQUFRLFdBQVcsT0FBTyxHQUFHLElBQUk7QUFDakQsVUFBTSxNQUFNLG1CQUFtQixPQUFPLEtBQUssRUFBRTtBQUU3QyxVQUFNLEVBQUUsV0FBVyxRQUFRLE9BQU8sb0JBQW9CLEdBQUc7QUFFekQsb0JBQWdCLFlBQVk7QUFDNUIsb0JBQWdCLFNBQVM7QUFDekIsb0JBQWdCLEtBQUs7QUFFckIsV0FBTztBQUFBLEVBQ1QsQ0FBQztBQUVELFNBQU87QUFDVDtBQTVCUyxBQWdDVCxNQUFNLHVCQUF1QjtBQUU3Qiw2QkFBNkIsS0FBaUI7QUFDNUMsUUFBTSxRQUFRO0FBQ2QsUUFBTSxPQUFPLElBQUksV0FBVyxFQUFFO0FBQzlCLFFBQU0sT0FBTyxNQUFNLFdBQVcsb0JBQW9CO0FBRWxELFFBQU0sQ0FBQyxXQUFXLFFBQVEsZUFBZSxpQ0FBYyxPQUFPLE1BQU0sSUFBSTtBQUV4RSxTQUFPO0FBQUEsSUFDTDtBQUFBLElBQ0E7QUFBQSxJQUNBLElBQUksWUFBWSxNQUFNLEdBQUcsRUFBRTtBQUFBLEVBQzdCO0FBQ0Y7QUFaUyxBQWNULDRCQUVFLFFBQ0EsTUFDQSxRQUNZO0FBQ1osUUFBTSxTQUFTLHVCQUFJLFFBQVEsSUFBSTtBQUMvQixNQUFJLFdBQVcsUUFBUSxXQUFXLFFBQVc7QUFDM0MsVUFBTSxJQUFJLE1BQU0sbUNBQW1DLE1BQU07QUFBQSxFQUMzRDtBQUVBLE1BQUksQ0FBQyw0QkFBUyxNQUFNLEdBQUc7QUFDckIsVUFBTSxJQUFJLE1BQU0sZ0RBQWdELE1BQU07QUFBQSxFQUN4RTtBQUVBLFFBQU0sU0FBUyxNQUFNLFdBQVcsTUFBTTtBQUN0QyxNQUFJLFVBQVUsT0FBTyxlQUFlLFFBQVE7QUFDMUMsVUFBTSxJQUFJLE1BQ1IsNkNBQTZDLE9BQU8seUJBQXlCLGtCQUFrQixNQUNqRztBQUFBLEVBQ0Y7QUFFQSxTQUFPO0FBQ1Q7QUF2QlMsQUEwQlQsb0JBQW9CLFFBQWEsTUFBc0I7QUFDckQsUUFBTSxTQUFTLHVCQUFJLFFBQVEsSUFBSTtBQUMvQixNQUFJLFdBQVcsUUFBUSxXQUFXLFFBQVc7QUFDM0MsVUFBTSxJQUFJLE1BQU0sMkJBQTJCLE1BQU07QUFBQSxFQUNuRDtBQUVBLE1BQUksNEJBQVMsTUFBTSxHQUFHO0FBQ3BCLFVBQU0sU0FBUyxTQUFTLFFBQVEsRUFBRTtBQUNsQyxRQUFJLENBQUMsNEJBQVMsTUFBTSxHQUFHO0FBQ3JCLFlBQU0sSUFBSSxNQUNSLHNEQUFzRCxnQkFDeEQ7QUFBQSxJQUNGO0FBRUEsUUFBSSxDQUFDLDZCQUFVLE1BQU0sR0FBRztBQUN0QixZQUFNLElBQUksTUFDUiw4Q0FBOEMsZ0JBQ2hEO0FBQUEsSUFDRjtBQUVBLFdBQU87QUFBQSxFQUNUO0FBRUEsTUFBSSxDQUFDLDZCQUFVLE1BQU0sR0FBRztBQUN0QixVQUFNLElBQUksTUFBTSx1Q0FBdUMsZ0JBQWdCO0FBQUEsRUFDekU7QUFFQSxTQUFPO0FBQ1Q7QUE1QlMiLAogICJuYW1lcyI6IFtdCn0K
